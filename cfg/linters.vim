" README
" COMPILATION DATABASE: It is necessary to tell the CPP based linters how to
" compile the program. It can be done by adding
" set(CMAKE_EXPORT_COMPILE_COMMANDS) in the CMakeLists or with the flag
" -DCMAKE_EXPORT_COMPILE_COMMANDS=ON in the cmake command. This will generate
"  a compilationcommands.json that needs to be read by setting the env
"  variable CPP_BUILD_DIR.
"
" Diagnotics params
let g:diags_at_startup = 0

" Mapping
nnoremap <silent><leader>lv :call SetDiagsState('TOGGLE')<CR>
nnoremap <silent><Leader>ls :call Genstubs()<CR>
nnoremap <silent><leader>ll <cmd>TroubleToggle document_diagnostics<cr>
nnoremap <silent><leader>lL <cmd>TroubleToggle<cr>
nnoremap <silent><leader>lr <cmd>TroubleToggle lsp_references<cr>
nnoremap <silent><leader>ld <cmd>TroubleToggle lsp_definitions<cr>
nnoremap <silent><leader>lh <cmd>lua vim.lsp.buf.hover()<cr>

" Needed to generate the event InsertLeave with C-c
imap <C-c> <Esc>

lua << EOF
-- Python params
local python_max_line_length = 90
local python_indent_size = 4 -- spaces
local python_docstring_style = 'sphinx'
local python_good_names = 'q1, q2, q3, q4, q5, q, i, j, k, df, dt, ax, t, f, e'
local python_flake8_ignore = 'S101, DAR402, F841, DU0116, S603, S607, DAR103, PIE790, PT006, D100, C812, PIE803, PIE789, E721, FS001, PD011, TC002, FS003'
local python_pylint_ignore = 'W0102, W0212, R0913, R0903, R0902, R0914, W0621, C0301, W0613, C0115, C0116, C0501, ' .. -- Overlapping or clashing with my format
                             'R6103, C0199, C0198, ' .. -- From extensions
                             'R0915, ' ..
                             'W0511, ' .. -- ule added by flake8
                             'C0209, ' .. -- Rule that forces fstring even in logging
                             'C0123, ' .. -- Annoting use isinstance instead of type
                             'C2001, ' .. -- Annoying "avoid comparison to zero"
                             'W9015, W0917, ' .. -- Overlapping with flake8-darglint
                             '' 

-- Yaml params
local yaml_max_line_length = 90

-- Cmake params
local cmake_max_line_length = 80
local cmake_indent_size = 4 -- spaces

-- C++ params
-- Generated by adding in the CMakeLists.txt set(CMAKE_EXPORT_COMPILE_COMMANDS ON).
-- This path is the dir (typically /build folder) where the output of this command
-- (compilationdatabase.json) is located
local cpp_compilation_database_dir = os.getenv('CPP_BUILD_DIR') 
local cpp_max_line_length = 90
local cpp_cpplint_ignore = '-whitespace/braces, -legal/copyright, -whitespace/newline'
local cpp_std_flag = 'c++17' -- c89, c99, c11, c++03, c++11, c++14, c++17, c++20. Empty means last std

require('lint').linters.flake8.args = {'--docstring-style', python_docstring_style, 
                                       '--max-line-length', python_max_line_length,
                                       '--ignore', python_flake8_ignore,
                                       '--indent-size', python_indent_size,
                                       '--format=%(path)s:%(row)d:%(col)d:%(code)s:%(text)s',
                                       '--no-show-source',
                                       '--percent-greedy', "2",
                                       '--format-greedy', "2",
                                       '--enable-extensions',"FS003",
                                       '--scan-host-site-packages',
                                       '-',}
require('lint').linters.mypy.args = {'--strict',
                                     '--warn-unreachable',
                                     '--show-column-numbers',
                                     '--hide-error-context',
                                     '--no-color-output',
                                     '--no-error-summary',
                                     '--no-pretty',}

require('lint').linters.pylint.args = {'--good-names', python_good_names,
                                       '--disable', python_pylint_ignore,
                                       '--enable-all-extensions',
                                       '-f', 'json',}

require('lint').linters.yamllint.args = {'-d', '{extends: default, rules: {line-length:{max: ' .. yaml_max_line_length ..'}}}',
                                         '--format', 'parsable'}

require('lint').linters.markdownlint.args = {'--disable=MD013'} -- line-length

require('lint').linters.clangtidy.ignore_exitcode = true
require('lint').linters.clangtidy.args = {'--extra-arg=-Wall',
                                          '--extra-arg=-Weverything',
                                          '--extra-arg=-pedantic',
                                          '--extra-arg=-std=' .. cpp_std_flag,
                                          '--extra-arg=-Wdocumentation',
                                          '--extra-arg=-Wno-c++98-compat',
                                          '--extra-arg=-Wno-missing-prototypes',
                                          '--extra-arg=-Wno-old-style-cast', --cpplint provides much more info
                                          '-p=' .. cpp_compilation_database_dir,
                                          '--quiet'}

require('lint').linters.cpplint.args = {'--linelength=' .. cpp_max_line_length,
                                        '--filter', cpp_cpplint_ignore,
                                        '--root', '..', --assuming that vim will be opened from the repository root
                                        '--quiet'}

require('lint').linters.cppcheck.args = {'--enable=all',
                                         '-I include',
                                         '--language=c++',
                                         '--std=' .. cpp_std_flag,
                                         '--inline-suppr',
                                         '--quiet',
                                         '--cppcheck-build-dir=' .. cpp_compilation_database_dir,
                                         '--template={file}:{line}:{column}: [{id}] {severity}: {message}'}

require('lint').linters.codespell.args = {'--builtin=clear,rare,code'}

require('lint').linters.cmakelint.args = {'--linelength=' .. cmake_max_line_length,
                                          '--spaces=' .. cmake_indent_size,
                                          '--quiet'}

require('lint').linters.rstlint.args = {'--level=info'}

require('lint').linters_by_ft = {
  --python = {'flake8', 'pylint', 'vulture', 'codespell', 'mypy', 'pytestcov'}, -- mypy is included in pylsp, but not in pyright
  --python = {'flake8', 'pylint', 'vulture', 'codespell', 'mypy'}, -- mypy is included in pylsp, but not in pyright
  python = {'flake8', 'vulture', 'codespell', 'mypy'}, -- mypy is included in pylsp, but not in pyright
 -- python = {'flake8', 'vulture', 'codespell', 'mypy', 'pytestcov'}, -- mypy is included in pylsp, but not in pyright
  --python = {'mypy'}, -- mypy is included in pylsp, but not in pyright
  cpp = {'cppcheck', 'clangtidy', 'cpplint', 'codespell'},
  rst = {'rstlint', 'rstcheck', 'proselint', 'codespell'},
  markdown = {'markdownlint', 'codespell', 'proselint'},
  yaml = {'yamllint', 'codespell'},
  cmake = {'cmakelint'},
  sh = {'shellcheck'},
  lua = {'luacheck'},
  vim = {'vint'},
}
EOF


" Generate stubs when the cursor is on the import/from
function! Genstubs()
    let l:line = getline('.')
    let l:words = split(l:line, '[ .]')
    let l:stubgen_args = 'stubgen -o $STUBSPATH '
    if l:words[0] == 'import'
"    Case1: Import XXX (as XXX) -m XXX 
        if l:words[2] == 'as'
            let l:stubgen_args = l:stubgen_args . '-m ' . l:words[1]
            echo 'Generating stubs for module ' . l:words[1]
"    Case2: Import XXX.XXX.XXX -p XXX (first)
        else
            let l:stubgen_args = l:stubgen_args . '-p ' . l:words[1]
            echo 'Generating stubs for package ' . l:words[1]
        endif
    endif
"    Case3: From XXX.XXX.XXX import XXX -p XXX (the first one)
    if l:words[0] == 'from'
        let l:stubgen_args = l:stubgen_args . '-p ' . l:words[1]
        echo 'Generating stubs for package ' . l:words[1]
    endif
    execute ':RunCMDSilent ' . l:stubgen_args
    echo 'Stubs generated'
endfunction


""" Linter toggler implementation "
if g:diags_at_startup == 0
    let g:mflova_diagnostics_status = 0
    let g:current_diags_state = 0
else
    let g:mflova_diagnostics_status = 1
    let g:current_diags_state = 1
    call SetDiagsState(1)
end

" Set up linters to its given filetype
function SetAutoLinters(mode)
    if a:mode == 'ON'
        let g:is_autolinters_defined = 1
        augroup auto_linters
            autocmd!
            " Launch the toggler but not in the exceptions
            au BufWritePost *.py,*.hpp,*.cpp,*.md,*.yaml,*.vim,*.bash,*.make,*.rst,*.lua,CMakeLists.txt call SetDiagsState('ON')
            au BufEnter *.py,*.hpp,*.cpp,*.md,*.yaml,*.vim,*.bash,*.make,*.rst,*.lua,CMakeLists.txt call SetDiagsState('ON')
        augroup end
    else
        if g:is_autolinters_defined
            silent autocmd! auto_linters
        endif
    end
endfunction

function! UpdateDiagnosticsStatusLine()
    let g:mflova_diagnostics_status = g:current_diags_state
endfunction

" Diags toggler
let g:is_autolinters_defined = 0
function SetDiagsState(mode)
    if a:mode == 'ON'
        let g:current_diags_state = 1
        " Enable virtual text and diags
        " Errors when many diagnostics
        silent! lua vim.diagnostic.enable()
        " Run lints
        execute "lua require('lint').try_lint()"
        " Set auto-linters
        call SetAutoLinters("ON")
    end
    if a:mode == 'OFF'
        let g:current_diags_state = 0
        " Disable virtual text and diags
        lua vim.diagnostic.disable()
        " Disable auto-linters
        call SetAutoLinters("OFF")
        " Update status bar
    end
    if a:mode == 'TOGGLE'
        if g:current_diags_state == 1
            let g:current_diags_state = 0
            lua vim.diagnostic.disable()
            call SetAutoLinters("OFF")
        elseif g:current_diags_state == 0
            let g:current_diags_state = 1
            " Errors when many diagnostics
            silent! lua vim.diagnostic.enable()
            execute "lua require('lint').try_lint()"
            call SetAutoLinters("ON")
        end
    end
    call UpdateDiagnosticsStatusLine()
endfunction

function! SaveDiagsState()
   let g:saved_diags_state = g:current_diags_state
endfunction

let g:saved_diags_state = g:current_diags_state

function! RestoreDiagsState()
    if g:saved_diags_state == 1
        call SetDiagsState('ON')
    else
        call SetDiagsState('OFF')
    end
endfunction

augroup linters_exception_files
    au BufEnter TODO.md,NOTES.md call SaveDiagsState() | call SetDiagsState('OFF')
    au BufLeave TODO.md,NOTES.md call RestoreDiagsState()
augroup end
"
